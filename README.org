* MatrixProtocolClient.jl

The is the README for the [[https://github.com/non-Jedi/MatrixProtocolClient.jl][MatrixProtocolClient.jl]] implementation of a client for
[[https://matrix.org/docs/spec/client_server/r0.3.0.html][version r0.3.0 of the matrix.org Client-Server API]]. As a [[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate program]], this
document is also the canonical source code for MatrixProtocolClient.jl.

All text in this document, the source code generated from this document, and all
other associated files are under copyright of [[Authors][the authors of
MatrixProtocolClient.jl]] unless otherwise noted. The aforementioned items are
available for your use subject to [[https://github.com/non-Jedi/MatrixProtocolClient.jl/blob/master/LICENSE.md][the GNU Public License, Version 3.0+]]. Within
this document, sections are quoted from the Client-Server API spec for matrix
and from [[https://github.com/matrix-org/matrix-doc/tree/client-server/r0.3.0/api][the swagger-compatible representation of the matrix APIs]]. All such
quotes will be called out with a footnote or some other attribution, and usage
of those quotes must follow the terms of [[https://github.com/matrix-org/matrix-doc/blob/client-server/r0.3.0/LICENSE][the license for the matrix.org
specification]].

** Contributing

At this time this project follows a workflow for non-core contributors as
follows:

1. Fork [[https://github.com/non-Jedi/MatrixProtocolClient.jl][the repository for this software on github]].
2. Checkout a new branch of the repository locally.
3. Make changes to README.org on your branch.
4. Add your name to [[Authors]].
5. Commit changes, trying your best to follow best practices for commit scoping
   and commit message formatting.
6. Push your branch back to a branch on your github fork of the project.
7. Issue a pull request from your branch to the master branch of the root
   repository.
8. I will review your pull request, merge it, generate the new "tangled" source
   code from README.org, and push a new commit to master.

If you are experienced with org-mode, you may include a commit generating new
source code in your pull request. A description of how to do so is available in
the org-mode documentation.

By issuing a pull request to this repository, you agree to release your
contribution under [[https://github.com/non-Jedi/MatrixProtocolClient.jl/blob/master/LICENSE.md][the terms of this project's license]].

** Authors
- [[https://matrix.to/#/@adam:thebeckmeyers.xyz][Adam Beckmeyer]]

** The Program

MatrixProtocolClient.jl is intended as a library to allow developers to easily
write applications making use of the matrix network or otherwise integrate the
matrix network into their Julia application. The initial scope of development
will be as follows, but more functionality may be added over time as needed or
implemented by other contributors:

- login/logout of matrix account
- join/leave matrix rooms
- send basic text messages into matrix rooms

This package makes some architectural decisions that may differ from normal
expectations (in addition to its nature as a literate program of course).
Although the Julia package ecosystem does not currently have [[https://sans-io.readthedocs.io/][a sans-io]]
implementation of HTTP, such a model is the preference of the library author, so
string representations of request/response bodies and query parameters will be
made available whenever practical. Rather than representing the many JSON forms
of matrix as hash maps, this library defines a native Julia struct to
deserialize/serialize JSON to/from. These structs will be generated from the
swagger-compatible representation of the API.

*** HTTP Endpoints

Here we'll create types and functions to make access of the matrix HTTP apis
convenient. First, we should make it possible to login.

**** Login

First of all, login endpoints along with many parts of matrix use "types" with
Java-style namespaces. For login, we have ~m.login.password~ for example. We'll
represent these with a simple parametric type with no fields where the parameter
will be a tuple of the form ~(:m, :login, :password)~. This will allow
specialization and dispatching on these types when they appear.

For convenience, we'll also define abstract types for grouping processed
requests and responses from the matrix server. In general, functions calling
matrix api endpoints should accept ~MatrixRequest~ type arguments and return
~MatrixResponse~.

#+NAME: matrix-type
#+BEGIN_SRC julia
  struct MatrixType{T} end

  abstract type MatrixRequest{M} end

  abstract type MatrixResponse end
#+END_SRC

Even though we're only designing the system for logging in now, we can see that
we'll need to be able to send a wide variety of HTTP requests. So let's define a
basic fallback function for that purpose.

#+NAME: matrix-request
#+BEGIN_SRC julia
  import HTTP

  export request

  """
      request(::MatrixRequest)::MatrixResponse

  Calls a matrix endpoint and returns a processed response.
  """
  function request(req::MatrixRequest)::MatrixResponse
      res = HTTP.request(method(req), url(req), headers(req), body(req))
      # We expect different response formats depending on details of request
      process_response(req, res)
  end#function
#+END_SRC

This begins to show us what methods need an implementation for all
~MatrixRequest~ types, defining the interface: 

- ~method~
- ~url~
- ~headers~
- ~body~
- ~process_response~
- ~response_type~ which will be shown later

For the first, this is why we made ~MatrixRequest~ parametric. We define
~method~ as follows.

#+NAME: method
#+BEGIN_SRC julia
  function method(req::MatrixRequest{M})::AbstractString where {M}
      if M in (:GET, :HEAD, :POST, :PUT, :DELETE, :TRACE, :OPTIONS, :CONNECT, :PATCH)
          string(M)
      else
          throw(DomainError(M, "Not a valid HTTP method."))
      end#if
  end#function
#+END_SRC

For ~url~, we will assume that ~MatrixRequest~ has a ~homeserver~ field. We also
must define ~path~ and ~query~ methods which will specify the ~path~ field and
no query params as the default case. We can override these assumption later if
necessary for specific types.

#+NAME: url
#+BEGIN_SRC julia
  import HTTP.URIs: URI

  url(req::MatrixRequest)::URI =
      URI(; host=req.homeserver, path=req.path, query=query(req))
  path(req::MatrixRequest) = req.path
  query(::MatrixRequest) = ""
#+END_SRC

Specific headers may be needed on each endpoint, but the most common header
needed by matrix is the ~Authorization~ header for transmitting the user's
access token. ~MatrixRequest~ types will have to opt out of having this token
sent in the headers.

#+NAME: headers
#+BEGIN_SRC julia
  headers(req::MatrixRequest) = defaultheaders(req)
  defaultheaders(req::MatrixRequest) = ("Authorization" => "Bearer " * token(req),)
  token(req::MatrixRequest) = req.token
#+END_SRC

~body(req)~ should default to empty since =GET= request shouldn't have bodies.

#+NAME: body
#+BEGIN_SRC julia
  body(::MatrixRequest) = Vector{UInt8}()
#+END_SRC

The most complicated of these methods is ~process_response~, and we get to
offload most of that to JSON2.jl. The most important part for us to implement is
making sure that each ~MatrixRequest~ provides JSON2 with a type it can parse
the response into. For return material that is not json, this method will need
to be overridden. As a default, if no custom type is provided, JSON2 will parse
the response into a NamedTuple.

#+NAME: process_response
#+BEGIN_SRC julia
  import JSON2

  function process_response(req::MatrixRequest, res::HTTP.Response)
      # TODO: error handling for failure to parse
      JSON2.read(String(res.body), response_type(req))
  end#function

  response_type(::MatrixRequest) = NamedTuple
#+END_SRC

#+BEGIN_SRC julia :tangle src/MatrixHTTP.jl :noweb yes :comments noweb
  module MatrixHTTP

  <<matrix-type>>
  <<matrix-request>>
  <<method>>
  <<url>>
  <<headers>>
  <<body>>
  <<process_response>>

  end#module
#+END_SRC

*** MatrixProtocolClient.jl

This file ties all of the previous work together, making modules available to
other modules, etc.

#+BEGIN_SRC julia :tangle src/MatrixProtocolClient.jl :comments noweb
  module MatrixProtocolClient

  include("MatrixHTTP.jl")

  end#module
#+END_SRC

This file runs all the tests written in other files.

#+BEGIN_SRC julia :tangle test/runtests.jl :comments noweb
  using Test

#+END_SRC
*** REQUIRE

In the absence of an [[https://github.com/python-hyper/hyper-h2][h2]]-style HTTP library for Julia, it uses the HTTP.jl
library for making requests to a matrix server and receiving responses. JSON2.jl
is used for deserializing JSON from matrix server responses and for constructing
JSON payloads. This =REQUIRE= file is used by current package registry rather
than the =Project.toml= with which it should be kept up to date.

#+BEGIN_SRC julia :tangle REQUIRE :eval never
  julia 1.0
  HTTP 0.7.1
  JSON2 0.2.3
#+END_SRC

*** Obsoleted 
These are sections of dead code that should probably be excised from the README
and program. Originally I had planned to auto-generate all HTTP endpoint
functions and types from the Swagger specification. Since there are no extent
Julia processors for Swagger, and the format is rather complex (and the matrix
Swagger is not always well-formed in the first place, this turned out to be more
difficult than it is worth.

**** Swagger processing                                                :TODO:

This section is not yet completed. The data model of swagger turned out to be
more complex than I thought. Some day if the matrix repo is using an up-to-date
version of OpenAPI, I may actually implement a full type generator for the
specification, but that is not an interesting way for me to use my freetime at
the moment.

Rather than digging into the vagaries of the specification for the swagger
specification, we choose the pragmatic approach of looking at the swagger files
for matrix and figuring out a "good enough" interpretation of them. If some day
in the future, a swagger/OpenAPI package exists for Julia, we will switch this
over to using that, but for now, writing such a package is bit farther than I'd
like to yak-shave today.

[[https://github.com/matrix-org/matrix-doc][The matrix documentation repository]] is cloned as a submodule of this repository
under the [[./matrix-doc][matrix-doc]] directory. Specifically, the swagger spec for the
client-server api is under [[./matrix-doc/api/client-server][matrix-doc/api/client-server]]. As a general example of
the structure of these swagger files, please reference [[./matrix-doc/api/client-server/sync.yaml][sync.yaml]].

What we ultimately want here is a macro that takes as input a path to a swagger
yaml file and creates a set of structs that can be used to encapsulate all
required values for requesting the endpoint and for processing the response.

We know the following about requests:

- tokens :: may be attached to any request as a query parameter or in a
            ~Authorization~ header as ~Bearer $access_token~ (not part of
            r0.3.0, but we'll include it anyway).
- Content-type :: for all requests will be ~application/json~
- ...

For this library, we will choose to pass access tokens in the header. So before
a request can be made to any endpoint, the following must be provided:

- ~Vector~ of ~Pair{String,String}~ of query parameters
- ~Vector~ of ~Pair~ of headers
- Body content encoded as a JSON ~String~.

***** Process swagger schema object

First we'll work towards generating a struct representing the body. Since a JSON
body is often nexted, as a simple first pass, this macro will be recursive,
defining structs for successive layers of the JSON body.

Before we can write the macros for generating request/response types, we'll need
some utility functions. The first turns the path from the swagger of the form
~"/_matrix/client/r0/login/"~ into an UpperCamelCase type name e.g. ~:Login~.
This function will return a symbol since it will be used in the various types'
names in the macro. We need this so we can call the struct for representing the
body of a request to the aforementioned endpoint something like
~:LoginRequestBody~.

#+NAME: function-typename
#+BEGIN_SRC julia
  """
      typename(path::AbstractString)::Symbol

  Returns a name for e.g. "/_matrix/client/r0/my/fun/path" like "MyFunPath".
  """
  function typename(path::AbstractString)::Symbol
      splitpath = split(path, "/"; keepempty=false)
      Symbol(join(titlecase.(splitpath[4:end]), ""))
  end
#+END_SRC

#+NAME: function-typename-test
#+BEGIN_SRC julia
  @test Swagger.typename("/_matrix/client/r0/my/fun/path") == :MyFunPath
#+END_SRC

Now we need a function that will insert a new field into a type expression.
Basically given an expression like ~:(struct Foo end)~, we want to be able to
call a function to create ~struct Foo; a::A end~ if given ~a~ and ~A~.

#+NAME: function-insertfield
#+BEGIN_SRC julia
  # Need convenience function to turn types into symbols/expressions for `insertfield!`
  "Inserts field `a` of type `T` into a type expression."
  function insertfield!(ex::Expr, a::Symbol, T::Union{Symbol,Expr})
      if ex.head == :struct
          push!(ex.args[end].args, :($a::$T))
      else
          throw(ArgumentError("Can only add field to concrete type expression"))
      end#if
  end#function
#+END_SRC

#+NAME: function-insertfield-test
#+BEGIN_SRC julia
  @testset "insertfield!" begin
      e = :(struct Foo; a::String end)
      Swagger.insertfield!(e, :b, :Int64)
      @test all(e.args[end].args[end-1:end] .== [:(a::String), :(b::Int64)])
      Swagger.insertfield!(e, :c, :(Vector{Int64}))
      @test all(e.args[end].args[end-2:end] .==
                [:(a::String), :(b::Int64), :(c::Vector{Int64})])
  end
#+END_SRC

To feed into this function, we need to be able to map from the types defined in
the JSON schema in the swagger to real concrete Julia types. Then we will have
all the information we need to parse the nested JSON objects into a set of
nested Julia types.

#+NAME: function-juliatype
#+BEGIN_SRC julia
  """
      juliatype(topleveltype::String[, nestedtypes...])::Type

  Return corresponding Julia type for a swagger type string.

  Throws ArgumentError for unknown types.
  """
  function juliatype(s::AbstractString, args...)::Union{Symbol,Expr}
      if s == "string"
          :String
      elseif s == "array" && !isempty(args)
          :(Vector{$(juliatype(args...))})
      elseif s == "object"
          :(Dict{String,Any})
      elseif s == "boolean"
          :Bool
      elseif s == "file"
          :IOBuffer
      elseif s == "integer"
          :Int64
      elseif s == "number"
          :Float64
      else
          throw(ArgumentError("No known corresponding Julia type"))
      end#if
  end#function
#+END_SRC

#+NAME: function-juliatype-test
#+BEGIN_SRC julia
  @testset "juliatype" begin
      @test Swagger.juliatype("boolean") == :Bool
      @test Swagger.juliatype("array", "object") == :(Vector{Dict{String,Any}})
      @test Swagger.juliatype("array", "array", "object") == :(Vector{Vector{Dict{String,Any}}})
  end
#+END_SRC

For a single endpoint, we must generate a base type for the endpoint, a type
representing the body of the request, a type representing the query params of
the request, and types representing each potential body for each potential
response. The first thing we do is define the abstract and parametric types that
will encapsulate these generated types.

Each endpoint will have a concrete type representing the endpoint itself. This
type will be used as parameters in Request types and Response types.

#+NAME: type-MatrixEndpoint
#+BEGIN_SRC julia
  "A single matrix endpoint."
  abstract type MatrixEndpoint end
#+END_SRC

For both requests and responses, bodies can have many different forms. We need
to be able to encode the endpoint these bodies belong to in the type system, so
we use the type representing the endpoint as a parameter on the supertype of all
bodies.

#+NAME: swagger-http-bodies
#+BEGIN_SRC julia
  "The body in any HTTP request or response."
  abstract type HTTPBody end

  "The body in an HTTP request to endpoint `T`."
  abstract type RequestBody{T<:MatrixEndpoint} <: HTTPBody end
  "The body from an HTTP response to endpoint T with status code `Status`."
  abstract type ResponseBody{T<:MatrixEndpoint,Status} <: HTTPBody end
#+END_SRC

One of the methods we'll need to define for each ~MatrixEndpoint~ is one to
return the endpoint path. We'll call this function ~path~ and define a generic
implementation throwing an error so that we can attach an appropriate docstring.

#+NAME: swagger-function-path
#+BEGIN_SRC julia
  """
      path(e::MatrixEndpoint)::Vector{<:AbstractString}

  Returns the path to an endpoint.

  Each element of the string represents part of the path. For a normal HTTP
  endpoint, they should be joined together with `/` characters and appended to the
  base URL of the homeserver.
  """
  path(::MatrixEndpoint) = throw(ArgumentError("Unknown endpoint path"))
#+END_SRC

We also need to create a function that generates that method for each endpoint
(expression that evaluates to a new method).

#+NAME: swagger-function-createpath
#+BEGIN_SRC julia
  """
      createpath(path::AbstractString)::Expr

  Returns an expression to add a method to `path` for an endpoint.
  """
  function createpath(path::AbstractString)::Expr
      endpoint = typename(path)
      :(path(::$endpoint) = $(split(path, "/"; keepempty=false)))
  end#function
#+END_SRC

#+NAME: swagger-function-createpath-test
#+BEGIN_SRC julia
  @testset "createpath" begin
      pathexpr = Swagger.createpath("/_matrix/client/r0/path/to/my/dreams")
      @test pathexpr.head == :(=)
      @test pathexpr.args[1] == :(path(::PathToMyDreams))
      @test all(pathexpr.args[end].args[end] .==
                ["_matrix", "client", "r0", "path", "to", "my", "dreams"])
  end#@testset
#+END_SRC

We will parse the swagger YAML to get a ~Dict{String,Any}~, and then we must
transform this ~Dict~ into an ~Expr~ representing a type. This type may have
fields that are of a type that also must be defined, so the function must emit a
~Vector~ of ~Expr~.

*Note: the below is not correct and was hacked together at around 1AM*

#+BEGIN_SRC julia
  """
      requestbodyschema(swagger, path, method)::Dict

  Returns the schema for the body of a request to a given `path` with `method`.
  """
  function requestbodyschema(
      swagger::Dict,
      path::AbstractString,
      method::AbstractString
  )::Dict
      params = swagger["paths"][path][method]["parameters"]
      # params: [{"in": "body", "schema": ...}, {"in": "...", ...}]
      schema = params[find(get.(params, "in", "") .== "body")[1]]["schema"]
  end#function

  """
      swagger2bodytype(swagger::Dict{String,Any}, path)::Vector{Expr}

  Returns type `Expr` representing request body from Swagger.
  """
  function swagger2bodytype(swagger::Dict,
                            path::AbstractString,
                            method::AbstractString)::Vector{Expr}
      schema = requestbodyschema(swagger, path, method)
      # check that shape of schema is as expected
      if schema["type"] != "object"
          throw(ArgumentError("Unexpected body type: $(schema[\"type\"])"))
      end#if
      properties = schema["properties"]
      # ex will be built up into body type
      ex = :(struct $(typename(swagger["basePath"] * path)) end)
      property_names = keys(properties)
      property_types = juliatype.(get.(get.(properties, property_names, nothing),
                                       "type",
                                       nothing))
      insertfield!.(ex, property_names, property_types)
      ex
  end#function
#+END_SRC

#+NAME: macro-process-schema
#+BEGIN_SRC julia
  macro process_schema(path::AbstractString, d::Dict)
      :(struct $path
        end)
  end

#+END_SRC

Now this should all be joined together in ~src~ and in ~test~.

#+BEGIN_SRC julia :tangle no :noweb yes :comments noweb
  module Swagger

  <<function-typename>>

  <<function-insertfield>>

  <<function-juliatype>>

  <<type-MatrixEndpoint>>

  <<swagger-http-bodies>>
    
  <<swagger-function-path>>

  <<swagger-function-createpath>>

  end#module
#+END_SRC

#+BEGIN_SRC julia :tangle no :noweb yes
  using MatrixProtocolClient.Swagger

  @testset "Utils" begin
      <<function-typename-test>>
      <<function-insertfield-test>>
      <<function-juliatype-test>>
      <<swagger-function-createpath-test>>
  end
#+END_SRC

